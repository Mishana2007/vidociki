require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const sqlite3 = require('sqlite3').verbose();
const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const YooKassa = require('yookassa');
const express = require('express');
const app = express();
const PORT = 3000;

const yooKassa = new YooKassa({
  shopId: process.env.YOOKASSA_SHOP_ID,
  secretKey: process.env.YOOKASSA_SECRET_KEY
});

const PAYMENT_OPTIONS = {
  small: { processes: 5, price: 199 },
  medium: { processes: 15, price: 745 },
  large: { processes: 30, price: 970 }
};

// Add to MESSAGES object
const paymentMessages = {
  paymentMenu: `
üí∞ *–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –∞–Ω–∞–ª–∏–∑–æ–≤:*

1Ô∏è‚É£ –ë–∞–∑–æ–≤—ã–π: 5 –∞–Ω–∞–ª–∏–∑–æ–≤ - 199‚ÇΩ
2Ô∏è‚É£ –°—Ç–∞–Ω–¥–∞—Ä—Ç: 15 –∞–Ω–∞–ª–∏–∑–æ–≤ - 745‚ÇΩ
3Ô∏è‚É£ –ü—Ä–µ–º–∏—É–º: 30 –∞–Ω–∞–ª–∏–∑–æ–≤ - 970‚ÇΩ`,

  paymentSuccess: (package) => `
‚úÖ *–û–ø–ª–∞—Ç–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!*
üì¶ –ü–∞–∫–µ—Ç: ${package.name}
üéØ –î–æ–±–∞–≤–ª–µ–Ω–æ –∞–Ω–∞–ª–∏–∑–æ–≤: +${package.processes}`,

  paymentPending: `
‚è≥ *–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã*
–û–ø–ª–∞—Ç–∏—Ç–µ –∑–∞–∫–∞–∑ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ`
};

const CHANNEL_USERNAME = '@fghjyhnbvft';
const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const DAILY_LIMIT = 1;
const INITIAL_LIMIT = 3;
const BOT_USERNAME = '@MasterWords_bot';

const db = new sqlite3.Database('bot_database.db');
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS users (
      user_id INTEGER PRIMARY KEY,
      username TEXT,
      first_name TEXT,
      remaining_processes INTEGER DEFAULT ${INITIAL_LIMIT},
      last_reset_date TEXT,
      registration_date TEXT DEFAULT CURRENT_TIMESTAMP,
      referral_code TEXT UNIQUE,
      referred_by TEXT
    )
  `);
  
  db.run(`
    CREATE TABLE IF NOT EXISTS referral_uses (
      referral_code TEXT,
      used_by INTEGER,
      used_date TEXT,
      UNIQUE(referral_code, used_by)
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS payments (
      payment_id TEXT PRIMARY KEY,
      user_id INTEGER,
      package_type TEXT,
      amount INTEGER,
      status TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    )
  `);

});

const bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true });
const genAI = new GoogleGenerativeAI(process.env.GENAI);

function getTimeUntilMidnight() {
  const now = new Date();
  const midnight = new Date(now);
  midnight.setHours(24, 0, 0, 0);
  const diff = midnight - now;
  return {
    hours: Math.floor(diff / (1000 * 60 * 60)),
    minutes: Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
  };
}

function generateReferralCode(length = 8) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  return Array.from({ length }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');
}

const MESSAGES = {
  welcome: (remaining) => {
    const time = getTimeUntilMidnight();
    return `
üé• *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Video Analysis Bot!*

–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ –≤–∏–¥–µ–æ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ä–∞–∑–±–æ—Ä.

üìå *–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç:*
1. –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª
2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∏–¥–µ–æ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
3. –ü–æ–ª—É—á–∏—Ç–µ –¥–µ—Ç–∞–ª—å–Ω—ã–π —Ä–∞–∑–±–æ—Ä

‚ö°Ô∏è *–°–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–æ–≤:*
‚Ä¢ ${INITIAL_LIMIT} –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
‚Ä¢ +${DAILY_LIMIT} –∞–Ω–∞–ª–∏–∑ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
‚Ä¢ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã –∑–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è

üéØ *–î–æ—Å—Ç—É–ø–Ω–æ –∞–Ω–∞–ª–∏–∑–æ–≤:* ${remaining}
‚è∞ *–°–ª–µ–¥—É—é—â–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑:* ${time.hours}—á ${time.minutes}–º

üí´ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /ref –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–∏`;
  },

  subscribe: `
‚ùóÔ∏è *–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –ø–æ–¥–ø–∏—Å–∫–∞*

–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞:
1Ô∏è‚É£ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª ${CHANNEL_USERNAME}
2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ª—é–±–æ–µ –≤–∏–¥–µ–æ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
3Ô∏è‚É£ –ü–æ–ª—É—á–∏—Ç–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ä–∞–∑–±–æ—Ä`,

  processing: `
üîÑ *–ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑ –≤–∞—à–µ–≥–æ –≤–∏–¥–µ–æ*

‚è≥ –≠—Ç–æ –∑–∞–π–º–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç
üìù –í—ã –ø–æ–ª—É—á–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π —Ä–∞–∑–±–æ—Ä –≤—Å–µ—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏—è`,

  complete: `
‚úÖ *–ê–Ω–∞–ª–∏–∑ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω*

üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∏–∂–µ`,

  error: `
‚ùå *–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤–∏–¥–µ–æ*

–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:
‚Ä¢ –§–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
‚Ä¢ –†–∞–∑–º–µ—Ä –ø—Ä–µ–≤—ã—à–∞–µ—Ç 20MB
‚Ä¢ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –Ω–µ–ø–æ–ª–∞–¥–∫–∏`,

  limitReached: (time) => `
‚ö†Ô∏è *–õ–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω*

‚Ä¢ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å
‚Ä¢ +${DAILY_LIMIT} –∞–Ω–∞–ª–∏–∑ –∑–∞–≤—Ç—Ä–∞
‚Ä¢ –î–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ${time.hours}—á ${time.minutes}–º

üí° –ü–æ–ª—É—á–∏—Ç–µ –±–æ–ª—å—à–µ –∞–Ω–∞–ª–∏–∑–æ–≤:
‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–∑–µ–π —á–µ—Ä–µ–∑ /ref
‚Ä¢ –î–æ–∂–¥–∏—Ç–µ—Å—å –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è`,

  referral: (code) => `
üéÅ *–í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:*

https://t.me/${BOT_USERNAME}?start=${code}

–ó–∞ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤—ã –ø–æ–ª—É—á–∏—Ç–µ:
‚Ä¢ +2 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–∞
‚Ä¢ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–ø–∏—Ç—å –∞–Ω–∞–ª–∏–∑—ã

üîÑ –°—Å—ã–ª–∫–∞ –º–Ω–æ–≥–æ—Ä–∞–∑–æ–≤–∞—è`
};

async function getReferralCode(userId) {
  return new Promise((resolve, reject) => {
    db.get('SELECT referral_code FROM users WHERE user_id = ?', [userId], async (err, user) => {
      if (err) return reject(err);
      
      if (user?.referral_code) {
        resolve(user.referral_code);
      } else {
        const code = generateReferralCode();
        db.run('UPDATE users SET referral_code = ? WHERE user_id = ?', [code, userId], (err) => {
          if (err) reject(err);
          else resolve(code);
        });
      }
    });
  });
}

async function addReferralBonus(userId) {
  return new Promise((resolve, reject) => {
    db.run(
      'UPDATE users SET remaining_processes = remaining_processes + 2 WHERE user_id = ?',
      [userId],
      err => err ? reject(err) : resolve()
    );
  });
}

async function processReferral(userId, referralCode) {
  return new Promise((resolve, reject) => {
    db.get(
      'SELECT user_id FROM users WHERE referral_code = ?',
      [referralCode],
      async (err, referrer) => {
        if (err) return reject(err);
        if (!referrer) return resolve(false);

        try {
          await db.run(
            'INSERT INTO referral_uses (referral_code, used_by, used_date) VALUES (?, ?, ?)',
            [referralCode, userId, new Date().toISOString()]
          );
          await addReferralBonus(referrer.user_id);
          await db.run(
            'UPDATE users SET referred_by = ? WHERE user_id = ?',
            [referralCode, userId]
          );
          resolve(true);
        } catch (err) {
          resolve(false);
        }
      }
    );
  });
}

async function processVideo(videoPath) {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const videoData = fs.readFileSync(videoPath);
    const base64Video = videoData.toString('base64');
    
    const prompt = `
üìä –ê–ù–ê–õ–ò–ó –í–ò–î–ï–û–í–´–°–¢–£–ü–õ–ï–ù–ò–Ø

1Ô∏è‚É£ –ù–ï–í–ï–†–ë–ê–õ–¨–ù–ê–Ø –ö–û–ú–ú–£–ù–ò–ö–ê–¶–ò–Ø
‚Ä¢ –ñ–µ—Å—Ç—ã –∏ –¥–≤–∏–∂–µ–Ω–∏—è
‚Ä¢ –ü–æ–∑–∞ –∏ –æ—Å–∞–Ω–∫–∞
‚Ä¢ –ú–∏–º–∏–∫–∞ –∏ —ç–º–æ—Ü–∏–∏
‚Ä¢ –ó—Ä–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç
‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞

2Ô∏è‚É£ –†–ï–ß–¨ –ò –ì–û–õ–û–°
‚Ä¢ –¢–µ–º–ø –∏ —Ä–∏—Ç–º
‚Ä¢ –ì—Ä–æ–º–∫–æ—Å—Ç—å –∏ –∏–Ω—Ç–æ–Ω–∞—Ü–∏—è
‚Ä¢ –ß—ë—Ç–∫–æ—Å—Ç—å –ø—Ä–æ–∏–∑–Ω–æ—à–µ–Ω–∏—è
‚Ä¢ –ü–∞—É–∑—ã –∏ –∞–∫—Ü–µ–Ω—Ç—ã
‚Ä¢ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –æ–∫—Ä–∞—Å

3Ô∏è‚É£ –°–¢–†–£–ö–¢–£–†–ê
‚Ä¢ –õ–æ–≥–∏–∫–∞ –∏–∑–ª–æ–∂–µ–Ω–∏—è
‚Ä¢ –°–≤—è–∑–Ω–æ—Å—Ç—å –º—ã—Å–ª–µ–π
‚Ä¢ –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã
‚Ä¢ –†–∞–±–æ—Ç–∞ —Å –∞—É–¥–∏—Ç–æ—Ä–∏–µ–π

4Ô∏è‚É£ –û–ë–©–ê–Ø –û–¶–ï–ù–ö–ê
‚Ä¢ –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã
‚Ä¢ –û–±–ª–∞—Å—Ç–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è
‚Ä¢ –†–µ–π—Ç–∏–Ω–≥ –ø–æ 10-–±–∞–ª–ª—å–Ω–æ–π —à–∫–∞–ª–µ

5Ô∏è‚É£ –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò
‚Ä¢ 3-5 –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å–æ–≤–µ—Ç–æ–≤
‚Ä¢ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è
‚Ä¢ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏`;

    const parts = [{
      inlineData: {
        data: base64Video,
        mimeType: 'video/mp4'
      }
    }, prompt];

    const result = await model.generateContent(parts);
    return result.response.text();
  } catch (error) {
    console.error('Video processing error:', error);
    throw error;
  }
}

async function isSubscribed(chatId) {
  try {
    const member = await bot.getChatMember(CHANNEL_USERNAME, chatId);
    return ['creator', 'administrator', 'member'].includes(member.status);
  } catch {
    return false;
  }
}

async function createPayment(userId, packageType) {
  const package = PAYMENT_OPTIONS[packageType];
  
  const payment = await yooKassa.createPayment({
    amount: {
      value: package.price.toFixed(2),
      currency: 'RUB'
    },
    confirmation: {
      type: 'redirect',
      return_url: `https://t.me/${BOT_USERNAME}`
    },
    metadata: {
      user_id: userId,
      package_type: packageType
    }
  });

  await db.run(
    'INSERT INTO payments (payment_id, user_id, package_type, amount, status) VALUES (?, ?, ?, ?, ?)',
    [payment.id, userId, packageType, package.price, 'pending']
  );

  return payment;
}

async function processSuccessfulPayment(paymentId) {
  const payment = await db.get('SELECT * FROM payments WHERE payment_id = ?', [paymentId]);
  if (!payment || payment.status === 'completed') return;

  const package = PAYMENT_OPTIONS[payment.package_type];
  await db.run(
    'UPDATE users SET remaining_processes = remaining_processes + ? WHERE user_id = ?',
    [package.processes, payment.user_id]
  );
  
  await db.run(
    'UPDATE payments SET status = ? WHERE payment_id = ?',
    ['completed', paymentId]
  );

  return { userId: payment.user_id, package: {
    name: payment.package_type,
    processes: package.processes
  }};
}

// Add payment command handler
bot.onText(/\/pay/, async (msg) => {
  const chatId = msg.chat.id;

  const keyboard = {
    inline_keyboard: [
      [{ text: '5 –∞–Ω–∞–ª–∏–∑–æ–≤ - 199‚ÇΩ', callback_data: 'pay_small' }],
      [{ text: '15 –∞–Ω–∞–ª–∏–∑–æ–≤ - 745‚ÇΩ', callback_data: 'pay_medium' }],
      [{ text: '30 –∞–Ω–∞–ª–∏–∑–æ–≤ - 970‚ÇΩ', callback_data: 'pay_large' }]
    ]
  };

  await bot.sendMessage(chatId, paymentMessages.paymentMenu, {
    parse_mode: 'Markdown',
    reply_markup: keyboard
  });
});

async function checkProcessingLimit(userId) {
  return new Promise((resolve, reject) => {
    const currentDate = new Date().toISOString().split('T')[0];
    db.get('SELECT * FROM users WHERE user_id = ?', [userId], (err, user) => {
      if (err) return reject(err);
      
      if (!user) {
        db.run('INSERT INTO users (user_id, remaining_processes, last_reset_date) VALUES (?, ?, ?)',
          [userId, INITIAL_LIMIT, currentDate]);
        resolve({ canProcess: true, remaining: INITIAL_LIMIT });
      } else if (user.last_reset_date !== currentDate) {
        
        db.run('UPDATE users SET remaining_processes = ?, last_reset_date = ? WHERE user_id = ?',
          [DAILY_LIMIT, currentDate, userId]);
        resolve({ canProcess: true, remaining: DAILY_LIMIT });
      } else {
        resolve({ 
          canProcess: user.remaining_processes > 0,
          remaining: user.remaining_processes
        });
      }
    });
  });
}

async function decreaseProcessingCount(userId) {
  return new Promise((resolve, reject) => {
    db.run('UPDATE users SET remaining_processes = remaining_processes - 1 WHERE user_id = ?',
      [userId], err => err ? reject(err) : resolve());
  });
}

async function sendLongMessage(chatId, text) {
  const maxLength = 4096;
  const parts = [];
  let message = text;

  while (message.length > 0) {
    if (message.length > maxLength) {
      let part = message.substr(0, maxLength);
      const lastNewline = part.lastIndexOf('\n');
      
      if (lastNewline !== -1) {
        part = message.substr(0, lastNewline);
        message = message.substr(lastNewline + 1);
      } else {
        message = message.substr(maxLength);
      }
      parts.push(part);
    } else {
      parts.push(message);
      message = '';
    }
  }

  for (const part of parts) {
    await bot.sendMessage(chatId, part);
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
}

bot.onText(/\/start (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const referralCode = match[1];

  const subscribed = await isSubscribed(chatId);
  if (!subscribed) {
    await bot.sendMessage(chatId, MESSAGES.subscribe, { parse_mode: 'Markdown' });
    return;
  }

  await processReferral(chatId, referralCode);
  const limits = await checkProcessingLimit(chatId);
  await bot.sendMessage(
    chatId,
    MESSAGES.welcome(limits.remaining),
    { parse_mode: 'Markdown' }
  );
});

bot.onText(/\/start$/, async (msg) => {
  const chatId = msg.chat.id;
  
  const subscribed = await isSubscribed(chatId);
  if (!subscribed) {
    await bot.sendMessage(chatId, MESSAGES.subscribe, { parse_mode: 'Markdown' });
    return;
  }

  const limits = await checkProcessingLimit(chatId);
  await bot.sendMessage(
    chatId,
    MESSAGES.welcome(limits.remaining),
    { parse_mode: 'Markdown' }
  );
});

bot.onText(/\/ref/, async (msg) => {
  const chatId = msg.chat.id;
  
  const subscribed = await isSubscribed(chatId);
  if (!subscribed) {
    await bot.sendMessage(chatId, MESSAGES.subscribe, { parse_mode: 'Markdown' });
    return;
  }

  const referralCode = await getReferralCode(chatId);
  await bot.sendMessage(
    chatId,
    MESSAGES.referral(referralCode),
    { parse_mode: 'Markdown' }
  );
});

// [Previous code remains the same until the video handler]

bot.on('video', async (msg) => {
  const chatId = msg.chat.id;
  
  try {
    const subscribed = await isSubscribed(chatId);
    if (!subscribed) {
      await bot.sendMessage(chatId, MESSAGES.subscribe, { parse_mode: 'Markdown' });
      return;
    }

    const limits = await checkProcessingLimit(chatId);
    if (!limits.canProcess) {
      const time = getTimeUntilMidnight();
      await bot.sendMessage(
        chatId,
        MESSAGES.limitReached(time),
        { parse_mode: 'Markdown' }
      );
      return;
    }

    const processingMsg = await bot.sendMessage(
      chatId,
      MESSAGES.processing,
      { parse_mode: 'Markdown' }
    );

    const file = await bot.getFile(msg.video.file_id);
    const videoPath = path.join(__dirname, `video_${Date.now()}.mp4`);
    const videoUrl = `https://api.telegram.org/file/bot${TELEGRAM_TOKEN}/${file.file_path}`;
    
    const response = await fetch(videoUrl);
    const buffer = await response.buffer();
    fs.writeFileSync(videoPath, buffer);

    const result = await processVideo(videoPath);
    
    await bot.deleteMessage(chatId, processingMsg.message_id);
    await bot.sendMessage(chatId, MESSAGES.complete, { parse_mode: 'Markdown' });
    await sendLongMessage(chatId, result);
    await decreaseProcessingCount(chatId);

    const remainingLimits = await checkProcessingLimit(chatId);
    const time = getTimeUntilMidnight();
    await bot.sendMessage(
      chatId,
      `üìà *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞*

‚Ä¢ –û—Å—Ç–∞–ª–æ—Å—å –∞–Ω–∞–ª–∏–∑–æ–≤: ${remainingLimits.remaining}
‚Ä¢ –î–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ${time.hours}—á ${time.minutes}–º

üí° –ü–æ–ª—É—á–∏—Ç–µ –±–æ–ª—å—à–µ –∞–Ω–∞–ª–∏–∑–æ–≤:
‚Ä¢ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–∑–µ–π —á–µ—Ä–µ–∑ /ref
‚Ä¢ –î–æ–∂–¥–∏—Ç–µ—Å—å –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è`,
      { parse_mode: 'Markdown' }
    );

    try {
      fs.unlinkSync(videoPath);
    } catch (err) {
      console.error('Error deleting video file:', err);
    }
  } catch (error) {
    console.error('Error:', error);
    await bot.sendMessage(chatId, MESSAGES.error, { parse_mode: 'Markdown' });
  }
});

// Add callback handler for payment buttons
bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  
  if (query.data.startsWith('pay_')) {
    const packageType = query.data.split('_')[1];
    
    try {
      const payment = await createPayment(chatId, packageType);
      
      await bot.sendMessage(chatId, paymentMessages.paymentPending, {
        parse_mode: 'Markdown'
      });
      
      await bot.sendMessage(chatId, `[–û–ø–ª–∞—Ç–∏—Ç—å](${payment.confirmation.confirmation_url})`, {
        parse_mode: 'Markdown'
      });
    } catch (error) {
      console.error('Payment error:', error);
      await bot.sendMessage(chatId, MESSAGES.error);
    }
  }
});

app.post('/webhook/payment', express.json(), async (req, res) => {
  const { event, object } = req.body;
  
  if (event === 'payment.succeeded') {
    try {
      const result = await processSuccessfulPayment(object.id);
      if (result) {
        await bot.sendMessage(
          result.userId,
          paymentMessages.paymentSuccess(result.package),
          { parse_mode: 'Markdown' }
        );
      }
    } catch (error) {
      console.error('Payment processing error:', error);
    }
  }
  
  res.sendStatus(200);
});

// Add error handling for unexpected errors
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});

process.on('unhandledRejection', (err) => {
  console.error('Unhandled Rejection:', err);
});

// Add periodic cleanup of old video files
setInterval(() => {
  const directory = __dirname;
  fs.readdir(directory, (err, files) => {
    if (err) return;
    
    files.forEach(file => {
      if (file.startsWith('video_') && file.endsWith('.mp4')) {
        const filePath = path.join(directory, file);
        fs.unlink(filePath, err => {
          if (err) console.error('Error deleting old video file:', err);
        });
      }
    });
  });
}, 3600000); // Cleanup every hour

// Start bot
console.log('üöÄ Bot started successfully');
